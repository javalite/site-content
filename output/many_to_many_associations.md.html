<p>Many-to-many associations | <a href="/activejdbc">ActiveJDBC</a>,Many-to-many associations</p>
<h1 id="many-to-many-associations">Many-to-many associations</h1>
<div id="toc"></div>

<p>Often times the database-driven applications require many to many relationships. These are the kind where an entity can have many other entities and also belong to the same type of entities. Examples in real life are: doctor treats many patients, and a patient sees many doctors. Another examples is when a university course has many students and a student has registered for many courses. In order to replicate this type of a relationship, usually three tables are created, one for the first type of entity, the other for another type of entity and a middle table which binds entities from the first two tables.</p>
<h2 id="example-tables">Example tables</h2>
<p>Let's see an example based on doctors and patients.</p>
<p>Table <code>DOCTORS</code>:</p>
<table>
<col width="6%" />
<col width="18%" />
<col width="16%" />
<col width="25%" />
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">first_name</th>
<th align="left">last_name</th>
<th align="left">discipline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">John</td>
<td align="left">Doe</td>
<td align="left">otholaringology</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">Hellen</td>
<td align="left">Hunt</td>
<td align="left">dentistry</td>
</tr>
</tbody>
</table>
<p>Table <code>PATIENTS</code>:</p>
<table>
<col width="6%" />
<col width="18%" />
<col width="18%" />
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">first_name</th>
<th align="left">last_name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">Jim</td>
<td align="left">Cary</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">John</td>
<td align="left">Carpenter</td>
</tr>
</tbody>
</table>
<p>There is nothing in these to tables that tell us that doctors and patients are somehow related. The third table binds entities between the doctors and patients table:</p>
<p>Table <code>DOCTORS_PATIENTS</code>:</p>
<table>
<col width="6%" />
<col width="16%" />
<col width="18%" />
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">doctor_id</th>
<th align="left">patient_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Looking at this table, we can discern that a doctor with ID = 1 (John Doe) has two patients: Jim Cary and John Carpenter. However Jim Cary also sees doctor Hellen Hunt. Let's see what kind of a support ActiveJDBC provides when it comes to many to many relationship. We will use the same table we outlined above.</p>
<h2 id="writing-models">Writing models</h2>
<p>Model for table <code>DOCTORS</code>:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Doctor <span class="kw">extends</span> Model {}</code></pre>
<p>Model for table <code>PATIENT</code>:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Patient <span class="kw">extends</span> Model {}</code></pre>
<p>Model for table <code>DOCTORS_PATIENTS</code>:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> DoctorsPatients <span class="kw">extends</span> Model {}</code></pre>
<p>In cases when you override conventions, creation of a model that represents a join table is optional</p>
<p>ActiveJDBC will use inflections to map these models to the tables. It also expects the <code>DOCTORS_PATIENTS</code> table to have <code>doctor_id</code> and <code>patient_id</code> columns. If everything is named appropriately (there are ways to override these conventions, see below), then the many to many relationships are configured across Doctor and Patient models. All the usual CRUD operations are supported right out of the box, see below.</p>
<h2 id="many-to-many-operations">Many-to-many operations</h2>
<h3 id="select-related-objects">Select related objects</h3>
<p>The select API for many to many is identical that of one to many, The framework is smart enough figure this out:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="co">//Let&#39;s lookup a doctor:</span>
Doctor doctor = Doctor.<span class="fu">findById</span>(<span class="dv">1</span>);
<span class="co">//get all patients of this doctor</span>
List&lt;Patient&gt; patients = doctor.<span class="fu">getAll</span>(Patient.<span class="fu">class</span>);
System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Doctor 1 has &quot;</span> + patients.<span class="fu">size</span>() + <span class="st">&quot; patient(s)&quot;</span>);<span class="co">//prints &quot;Doctor 1 has 2 patient(s)&quot;</span>

<span class="co">//Lookup a second doctor:</span>
doctor = Doctor.<span class="fu">findById</span>(<span class="dv">2</span>);
patients = doctor.<span class="fu">getAll</span>(Patient.<span class="fu">class</span>);
System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Doctor 2 has &quot;</span> + patients.<span class="fu">size</span>() + <span class="st">&quot; patient(s)&quot;</span>);<span class="co">//prints &quot;Doctor 1 has 1 patient(s)&quot;</span></code></pre>
<p>The framework will generate appropriate select statement and execute it across two tables. This allows focusing on objects and abstract away from tabular nature of data in the DB.</p>
<h3 id="conditional-selection-of-related-objects">Conditional selection of related objects</h3>
<p>ActiveJDBC provides a way to filter related objects. Let's say that there are tables <code>PROGRAMMERS</code>, <code>PROJECTS</code> and <code>PROGRAMMERS_PROJECTS</code>. In this case, we will create a model <code>Assignments</code> that will represent the join table:</p>
<pre class="sourceCode java"><code class="sourceCode java">@<span class="fu">Table</span>(<span class="st">&quot;programmers_projects&quot;</span>)
<span class="kw">public</span> <span class="kw">class</span> Assignments <span class="kw">extends</span> Model{}</code></pre>
<p>as well as other models:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> Project <span class="kw">extends</span> Model{}
..
<span class="kw">public</span> <span class="kw">class</span> Programmer <span class="kw">extends</span> Model{}</code></pre>
<p>You can treat a Many-to-many relationship as two one-to-many relationships. In this case, you could say that a project has many assignments and a programmer has many assignments. Armed with this knowledge, we can write some code:</p>
<pre class="sourceCode java"><code class="sourceCode java">Programmer programmer = Programmer.<span class="fu">createIt</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;Jim&quot;</span>, <span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Garnoe&quot;</span>);

Assignment assignment = Assignment.<span class="fu">createIt</span>(<span class="st">&quot;duration_weeks&quot;</span>, <span class="dv">3</span>);
<span class="co">//use one to many notation here:</span>
programmer.<span class="fu">add</span>(assignment);
Project project1 = Project.<span class="fu">createIt</span>(<span class="st">&quot;project_name&quot;</span>, <span class="st">&quot;Prove theory of everything&quot;</span>);
project1.<span class="fu">add</span>(assignment);

<span class="co">//use many to many notation:</span>
Project project2 = Project.<span class="fu">createIt</span>(<span class="st">&quot;project_name&quot;</span>, <span class="st">&quot;Find meaning of life&quot;</span>);
programmer.<span class="fu">add</span>(project2);</code></pre>
<p>at this point, the table <code>PROGRAMMERS_PROJECTS</code> will have the following content:</p>
<table>
<col width="5%" />
<col width="17%" />
<col width="13%" />
<col width="16%" />
<col width="23%" />
<col width="23%" />
<thead>
<tr class="header">
<th align="left">id</th>
<th align="left">duration_weeks</th>
<th align="left">project_id</th>
<th align="left">programmer_id</th>
<th align="left">created_at</th>
<th align="left">updated_at</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">3</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2010-10-04 14:08:04</td>
<td align="left">2010-10-04 14:08:04</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">NULL</td>
<td align="left">2</td>
<td align="left">1</td>
<td align="left">2010-10-04 14:08:04</td>
<td align="left">2010-10-04 14:08:04</td>
</tr>
</tbody>
</table>
<p>Where the first assignment is set for 3 weeks, and a second has no <code>duration_weeks</code> value.</p>
<p>Having this data, we can query many to many relationship using a select filter on a join table:</p>
<pre class="sourceCode java"><code class="sourceCode java">List&lt;Project&gt; projects = programmer.<span class="fu">get</span>(Project.<span class="fu">class</span>, <span class="st">&quot;duration_weeks = ?&quot;</span>, <span class="dv">3</span>);</code></pre>
<p>The result will be only one record. Unlike the <a href="one_to_many_associations">One-to-many associations</a>, the query is applied to a join table, and not the &quot;child&quot;.</p>
<h3 id="checking-for-association">Checking for association</h3>
<p>This is pretty simple:</p>
<pre class="sourceCode java"><code class="sourceCode java">System.<span class="fu">out</span>.<span class="fu">println</span>(Patient.<span class="fu">belongsTo</span>(Doctor.<span class="fu">class</span>));<span class="co">//prints &quot;true&quot;</span></code></pre>
<p>This API is symmetrical for Many-to-many associations.</p>
<blockquote>
<p>The same API also works for <a href="one_to_many_associations">One-to-many associations</a>.</p>
</blockquote>
<h3 id="adding-new-entries">Adding new entries</h3>
<p>In many to many associations, there are no parents or children, as both sides of the association are equal.</p>
<p>Adding new entries then is pretty easy:</p>
<pre class="sourceCode java"><code class="sourceCode java">Doctor doctor = Doctor.<span class="fu">findById</span>(<span class="dv">1</span>);
Patient patient = Patient.<span class="fu">create</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;Jim&quot;</span>, <span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Smith&quot;</span>);
doctor.<span class="fu">add</span>(patient);</code></pre>
<p>Here you see an example of a shortcut for creation of models with the <code>create()</code> method.</p>
<blockquote>
<p>Adding a new entity is the same for <a href="one_to_many_associations">One-to-many associations</a>.</p>
</blockquote>
<p>Here, we are adding a newly created patient, which is does not exist in the database yet. In this case, the framework will create two new records in the DB: one for a new patient, and one in the `DOCTORS_PATIENTS1 table that binds a current doctor and a new patient.</p>
<p>In the case where a patient exists already, it will only add a join record in the <code>DOCTORS_PATIENTS</code> table.</p>
<h3 id="removing-entries">Removing Entries</h3>
<p>Removing is also easy:</p>
<pre class="sourceCode java"><code class="sourceCode java">doctor.<span class="fu">remove</span>(patient);</code></pre>
<p>Here, only a join table record is being removed, the actual patient record stays unchanged. In this case, tThe API for removing a child is the same for one-to-many as for many-to-many relationships, but semantics are different. In one-to-many association the child record will be removed from the DB.</p>
<h3 id="deleting-entries">Deleting Entries</h3>
<p>Deleting entries is similar to deleting in One to Many associations:</p>
<pre class="sourceCode java"><code class="sourceCode java">doctor.<span class="fu">deleteCascade</span>();</code></pre>
<p>However, semantics are different. In many to many relationships, the <code>model.deleteCascade()</code> method will do more than just delete this record. It will also discover all associated join tables and will delete records from them that match this models' ID value, effectively dis-associating it from all many to many relationships.</p>
<p>For more see here: <a href="delete_cascade">Delete cascade</a></p>
<h2 id="overriding-associations">Overriding associations</h2>
<p>If the naming conventions cannot be used, you can override the convention to let the framework know which models are bound in many-to-many association:</p>
<pre class="sourceCode java"><code class="sourceCode java">@<span class="fu">Many2Many</span>(other = Course.<span class="fu">class</span>, join = <span class="st">&quot;registrations&quot;</span>, sourceFKName = <span class="st">&quot;astudent_id&quot;</span>, targetFKName = <span class="st">&quot;acourse_id&quot;</span>)
<span class="kw">public</span> <span class="kw">class</span> Student <span class="kw">extends</span> Model {}</code></pre>
<p>Here, the <code>other</code> is a model that represents the other end of the relationship, <code>join</code> is a name of a join table (table in the middle), <code>sourceFKName</code> is a source foreign key name. A source is this model, in this case it is <code>Student</code>. This means that the framework will expect to find a column <code>astudent_id</code> in the table <code>registrations</code> and will assume that it contains keys of records of the <code>student</code> table. <code>targetFKName</code> is similar to the <code>sourceFKName</code>, but stands for a column <code>acourse_id</code> in the table <code>registrations</code> that contains keys to the records in the <code>courses</code> table.</p>
<p>The annotation <code>@Many2Many</code> is one-sided. This means that it provides enough information to the framework, and there is no need to add another one to the model Course (it will not break if you do though).</p>
<h2 id="real-models-for-join-tables">Real models for join tables</h2>
<p>If join tables are represented by real models, ActiveJDBC handles it transparently. To illustrate the doctor - patient example above, you might want to indicate where a specific patient is treated.You would then add a new column to the <code>DOCTORS_PATIENTS</code> table called <code>location</code>. Then you would define a model like so:</p>
<pre class="sourceCode java"><code class="sourceCode java">@<span class="fu">Table</span>(<span class="st">&quot;DOCTORS_PATIENTS&quot;</span>)
<span class="kw">class</span> DocPat <span class="kw">extends</span> Model{}</code></pre>
<p>In the case of the student/course, the join table already has a good name, so it is easy to define a new model:</p>
<pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Registration <span class="kw">extends</span> Model{}</code></pre>
<p>The table <code>REGISTRATIONS</code> might have additional data, such as registration type, etc.</p>
