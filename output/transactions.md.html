<div class="row">

    <div id="TOC" class="span3 bs-docs-sidebar">
        <ul>
        <li><a href="#transactions">Transactions</a><ul>
        <li><a href="#basic-flow-of-db-program">Basic flow of DB program</a></li>
        <li><a href="#simple-activejdbc-example">Simple ActiveJDBC Example</a></li>
        <li><a href="#transaction-related-apis">Transaction related APIs</a></li>
        <li><a href="#transacted-activejdbc-example">Transacted ActiveJDBC Example</a></li>
        <li><a href="#transactions-with-jndi">Transactions with JNDI</a></li>
        </ul></li>
        </ul>
    </div>

<div class="span9"><h1 id="transactions"><a href="#TOC">Transactions</a></h1>
                   <p>The goal of AciveJDBC from the ground up was to be a very thin veneer on top of JDBC. As such, the attention was given to simplify the DB access API, but at the same time not take control away from a developer.</p>
                   <h2 id="basic-flow-of-db-program"><a href="#TOC">Basic flow of DB program</a></h2>
                   <p>In any DB - backed program, you would:</p>
                   <ul>
                   <li>Open connection</li>
                   <li>Do stuff</li>
                   <li>Close connection</li>
                   </ul>
                   <p>Usually in Java ORMs there is an explicit connection or a manager object (EntityManager in JPA, SessionManager in Hibernate, etc.). Such an object is absent in ActiveJDBC.</p>
                   <h2 id="simple-activejdbc-example"><a href="#TOC">Simple ActiveJDBC Example</a></h2>
                   <p>Here is an example of the most basic of the ActiveJDBC application without transaction management:</p>
                   <pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) {
                      Base.<span class="fu">open</span>(<span class="st">&quot;com.mysql.jdbc.Driver&quot;</span>, <span class="st">&quot;jdbc:mysql://localhost/test&quot;</span>, <span class="st">&quot;the_user&quot;</span>, <span class="st">&quot;the_password&quot;</span>);
                      Employee e = <span class="kw">new</span> <span class="fu">Employee</span>();
                      e.<span class="fu">set</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;John&quot;</span>);
                      e.<span class="fu">set</span>(<span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Doe&quot;</span>);
                      e.<span class="fu">saveIt</span>();
                      Base.<span class="fu">close</span>();
                   }</code></pre>
                   <p>The call <code>Base.open()</code> opens a connection and attaches it to the current thread. All subsequent methods of all models reuse this connection. The call <code>Base.close()</code> closes connection and removes it from the current thread.</p>
                   <h2 id="transaction-related-apis"><a href="#TOC">Transaction related APIs</a></h2>
                   <p>...so far so good, but to transactions. ActiveJDBC does provide a few transaction-related convenience calls:</p>
                   <p>Starting transaction:</p>
                   <pre class="sourceCode java"><code class="sourceCode java">Base.<span class="fu">openTransaction</span>();</code></pre>
                   <p>Committing transaction:</p>
                   <pre class="sourceCode java"><code class="sourceCode java">Base.<span class="fu">commitTransaction</span>();</code></pre>
                   <p>and rolling back:</p>
                   <pre class="sourceCode java"><code class="sourceCode java">Base.<span class="fu">rollbackTransaction</span>();</code></pre>
                   <p>All these methods simply call <code>java.sql.Connection.setAutocommit(false)</code>, <code>java.sql.Connection.commit()</code> and <code>java.sql.Connection.rollback()</code> respectively, wrapping exceptions and logging events at INFO level.</p>
                   <p>As you can see, ActiveJDBC is not trying to do much here, just trying to not get in the way.</p>
                   <p>In cases where you need a finer control, you can get a current connection and perform pure JDBC operations on it:</p>
                   <pre class="sourceCode java"><code class="sourceCode java">java.<span class="fu">sql</span>.<span class="fu">Connection</span> con = Base.<span class="fu">connection</span>();
                   con.<span class="fu">setAutocommit</span>(<span class="kw">false</span>);
                   ...<span class="co">//or:</span>
                   Base.<span class="fu">connection</span>().<span class="fu">setAutocommit</span>(<span class="kw">false</span>);</code></pre>
                   <h2 id="transacted-activejdbc-example"><a href="#TOC">Transacted ActiveJDBC Example</a></h2>
                   <p>A simple program using transactions will look like this:</p>
                   <pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) {
                      <span class="kw">try</span>{
                         Base.<span class="fu">open</span>(<span class="st">&quot;com.mysql.jdbc.Driver&quot;</span>, <span class="st">&quot;jdbc:mysql://localhost/test&quot;</span>, <span class="st">&quot;the_user&quot;</span>, <span class="st">&quot;the_password&quot;</span>);
                         Base.<span class="fu">openTransaction</span>();
                         Employee e = <span class="kw">new</span> <span class="fu">Employee</span>();
                         e.<span class="fu">set</span>(<span class="st">&quot;first_name&quot;</span>, <span class="st">&quot;John&quot;</span>);
                         e.<span class="fu">set</span>(<span class="st">&quot;last_name&quot;</span>, <span class="st">&quot;Doe&quot;</span>);
                         e.<span class="fu">saveIt</span>();
                         Base.<span class="fu">commitTransaction</span>();
                      <span class="kw">catch</span>(Exception e){
                         Base.<span class="fu">rollbackTransaction</span>();
                      }<span class="kw">finally</span>{
                         Base.<span class="fu">close</span>();
                      }
                   }</code></pre>
                   <h2 id="transactions-with-jndi"><a href="#TOC">Transactions with JNDI</a></h2>
                   <p>Usually though, a connection is requested from a pool of a container, and transaction configuration is already provided by container configuration. In these cases, the usage is the same (almost), but you have to be aware that that some calls might not succeed, or you might have unexpected side effects by the driver. For example, if you request a connection from a pool, the transaction might start then, and when you call:</p>
                   <pre class="sourceCode java"><code class="sourceCode java">Base.<span class="fu">connection</span>().<span class="fu">setAutocommit</span>(<span class="kw">true</span>/<span class="kw">false</span>);</code></pre>
                   <p>, you might accidentally commit a transaction in progress (...or driver will ignore your call and do nothing).</p>
                   <p>ActiveJDBC does not add anything special here to what J2EE and JDBC already provide.</p>
                   <p>Here is an example of ActiveJDBC used in a MessageDriven Bean (JMS):</p>
                   <pre class="sourceCode java"><code class="sourceCode java">
                   <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onMessage</span>(Message m){
                      Base.<span class="fu">open</span>(<span class="st">&quot;myConnectionJNDIName&quot;</span>);
                      TextMessage tm = (TextMessage)m;
                      String content = tm.<span class="fu">getText</span>();
                      String name = tm.<span class="fu">getStringProperty</span>(<span class="st">&quot;name&quot;</span>);
                      <span class="kw">try</span>{
                         Article.<span class="fu">create</span>(<span class="st">&quot;name&quot;</span>, name, <span class="st">&quot;content&quot;</span>, content).<span class="fu">saveIt</span>();
                      }
                      <span class="kw">catch</span>(Exception e){
                        ctx.<span class="fu">setRollbackOnly</span>(); <span class="co">// == this will send the message back into queue</span>
                      }
                      <span class="kw">finally</span>{
                         Base.<span class="fu">close</span>();<span class="co">//always close connection</span>
                      }
                   }</code></pre>
                   <p>In the example above, the container will manage transactions. It will roll back both: the JDBC, as well as JMS transactions.</p></div></div>

