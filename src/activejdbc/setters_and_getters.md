Working with getters and setters | <a href="/activejdbc">ActiveJDBC</a>,Setters and getters

# Setters and getters

<div id="toc"></div>

Java development is all about getters and setters. Ever since the Java Beans framework introduced in 1997, this has become a blessing (and a plague some argue) in modern Java applications. ActiveJDBC does not require getters and setters for models. Since models already know all the allowable metadata from database at startup, they will perform validations of names of attributes.

## Built in getters and setters

ActiveJDBC provides two base methods for getting information from DB and putting it in:

~~~~ {.java}
Person p = Person.findById();
name = p.get("name");
~~~~

The `name` is a name of a column from a table PEOPLE. Same goes for a setter:

~~~~ {.java}
Person p = new Person();
p.set("name", "John");
p.save();
~~~~

## No "standard" setters/getters???

Well, no. ActiveJDBC will not provide these, and it will not generate them either (for now).
However, you can have them if you like:

~~~~ {.java}
public class Person extends Model{
   public void setFirstName(String firstName){
      set("first_name", firstName);
   }
}
~~~~

This will provide a safety net to those wishing some compiler static checking. Same goes for getters. If you are starting out with ActiveJDBC, I suggest you do not write setters and getters, but rather use the provided methods. After a day or two you will be surprised you ever wrote them before.

Correction: a year after not using getters and setters, we started adding them in order to achieve a few things:

-   IDE help - this actually improves productivity, since IDE helps typing and I do not have to remember the schema by heart
-   Self - documenting the schema
-   no need to use conversion methods like `getFloat("name")`
-   easy refactoring, since there is no need to track dynamic setters and getters across the project

With ActiveJDBC you can use any style you like.

##Type conversion getters

ActiveJDBC provides a number of type conversion getters:

~~~~ {.java}

Person p = Person.findById();
String  name = p.getString("name");
Timestamp dob = p.getTimestamp("dob");
...
~~~~

ActiveJDBC will do all possible to convert your data into the type. This also goes for CLOBs:

~~~~ {.java}
String body = article.get("body");
~~~~

If the "BODY" column in your table is CLOB, ActiveJDBC will automatically convert it to Java String.

Please, see [Clob support and caching](clob_support_and_caching)
as well as [JavaLite Commons Convert](http://javalite.github.io/activejdbc/org/javalite/common/Convert.html) class for more information.

## Recommendation: Use TDD, in combination with setters and getters


In our work, we start writing a test before writing much code. We create a one line model code, then start writing a test.
Inside the test, we write a piece of code I know will fail:

~~~~ {.java}
Page p  = new Page();
p.set("blah", 1);
~~~~

The table PEOPLE does not have a column "BLAH", and ActiveJDBC is conveniently telling me this:

~~~~ {.prettyprint}
java.lang.IllegalArgumentException: Attribute: 'blah' is not defined in model: 'class activejdbc.test_models.Person and also, did not find an association by the same name, 
available attributes: [id, updated_at, graduation_date, dob, name, last_name, created_at]
~~~~

From this message, I see that the allowed attributes are:

~~~~ {.prettyprint}
id, updated_at, graduation_date, dob, name, last_name, created_at
~~~~

which gives me all the information I need to start writing a real test.

Since I know from [Autogenerated Fields](autogenerated_fields) that `id`, `updated_at` and `created_at` are
auto-generated columns and I need not touch them, I'm left with these to work:

~~~~ {.prettyprint}
graduation_date, dob, name, last_name
~~~~

When we are done with the test, we have a piece of durable code which has captured required model behaviour.
We then proceed to implement the rest of the model code - necessary validations, other code, until the test starts to pass.
